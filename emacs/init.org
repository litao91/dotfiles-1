#+AUTHOR: Roman Coedo
#+TITLE: Emacs Settings

* I like lexical binding
#+BEGIN_SRC emacs-lisp :tangle yes :padline no
;;; -*- lexical-binding: t -*-
#+END_SRC

* Package management
** Cask
#+BEGIN_SRC emacs-lisp :tangle yes
(require 'cask "/usr/local/share/emacs/site-lisp/cask/cask.el")
(cask-initialize)
#+END_SRC

** Pallet
#+BEGIN_SRC emacs-lisp :tangle yes
(require 'pallet)
(pallet-mode t)
#+END_SRC

** Dependency management
#+BEGIN_SRC emacs-lisp :tangle yes
(setq ad-redefinition-action 'accept)
(require 'req-package)
#+END_SRC
   
* Platform
#+BEGIN_SRC emacs-lisp :tangle yes
  (menu-bar-mode -1)
  (toggle-scroll-bar -1)
  (tool-bar-mode -1)

  (when (memq window-system '(mac ns))
    (setq exec-path-from-shell-check-startup-files nil)
    (exec-path-from-shell-initialize)
    (exec-path-from-shell-copy-env "RBENV_ROOT")
    (exec-path-from-shell-copy-env "GHQ_ROOT")
    (exec-path-from-shell-copy-env "GOPATH")

    (setq mac-command-modifier 'meta
          mac-option-key-is-meta nil
          ns-use-native-fullscreen nil
          mac-option-modifier 'none
          system-uses-terminfo nil
          ring-bell-function 'ignore
          osx-clipboard-mode t)

    (define-key key-translation-map (kbd "˙") (kbd "H-1"))
    (define-key key-translation-map (kbd "∆") (kbd "H-2"))
    (define-key key-translation-map (kbd "˚") (kbd "H-3"))
    (define-key key-translation-map (kbd "¬") (kbd "H-4")))
#+END_SRC

* Interface
** Global interface settings
#+BEGIN_SRC emacs-lisp :tangle yes
  (if (display-graphic-p)
      (progn
        (scroll-bar-mode -1)
        (tool-bar-mode -1)))

  (setq inhibit-splash-screen t
        menu-bar-mode -1)
#+END_SRC

** Linum mode
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package linum
    :init
    (hl-line-mode t)
    (global-linum-mode t)
    :config
    (setq linum-format 'dynamic)

    (set-face-attribute 'linum nil :height 100)
    (defadvice linum-update-window (around linum-dynamic activate)
      "Number into string with enough spaces."
      (let* ((w (length (number-to-string
                         (count-lines (point-min) (point-max)))))
             (linum-format (concat " %" (number-to-string w) "d ")))
        ad-do-it)))
#+END_SRC

** Modeline
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package smart-mode-line
    :config
    (progn
      (setq sml/theme nil)
      (sml/setup)))
#+END_SRC

** Theme
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package gruvbox-theme
    :require smart-mode-line
    :config
    (load-theme 'gruvbox t)
    (set-frame-font (font-spec :family "Operator Mono" :size 16))
    (set-face-italic 'font-lock-comment-face t)
    (setq-default line-spacing 3))
#+END_SRC

* rcoedo
** Buffer
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun rcoedo/buffer/rename-current-file ()
    "Renames current buffer and file it is visiting."
    (interactive)
    (let ((name (buffer-name))
          (filename (buffer-file-name)))
      (if (not (and filename (file-exists-p filename)))
          (error "Buffer '%s' is not visiting a file!" name)
        (let ((new-name (read-file-name "New name: " filename)))
          (if (get-buffer new-name)
              (error "A buffer named '%s' already exists!" new-name)
            (rename-file filename new-name 1)
            (rename-buffer new-name)
            (set-visited-file-name new-name)
            (set-buffer-modified-p nil)
            (message "File '%s' successfully renamed to '%s'"
                     name (file-name-nondirectory new-name)))))))

  (defun rcoedo/buffer/delete-current-file ()
    "Removes file connected to current buffer and kills buffer."
    (interactive)
    (let ((filename (buffer-file-name))
          (buffer (current-buffer))
          (name (buffer-name)))
      (if (not (and filename (file-exists-p filename)))
          (ido-kill-buffer)
        (when (yes-or-no-p "Are you sure you want to remove this file? ")
          (delete-file filename)
          (kill-buffer buffer)
          (message "File '%s' successfully removed" filename)))))

  (defun rcoedo/buffer/emacs-buffer-p (name)
    "Returns true if the name matches an Emacs buffer."
    (string-match-p "\\*.*\\*" name))

  (defun rcoedo/buffer/next-non-emacs-buffer (&optional original)
    "Similar to next-buffer, but ignores emacs buffer such as *scratch*, *messages* etc."
    (interactive)
    (let ((tmp-orig (or original (buffer-name))))
      (next-buffer)
      (if (and
           (not (eq (buffer-name) tmp-orig))
           (rcoedo/buffer/emacs-buffer-p (buffer-name)))
          (rcoedo/buffer/next-non-emacs-buffer tmp-orig))))

  (defun rcoedo/buffer/previous-non-emacs-buffer (&optional original)
    "Similar to previous-buffer, but ignores emacs buffer such as *scratch*, *messages* etc."
    (interactive)
    (let ((tmp-orig (or original (buffer-name))))
      (previous-buffer)
      (if (and
           (not (eq (buffer-name) tmp-orig))
           (rcoedo/buffer/emacs-buffer-p (buffer-name)))
          (rcoedo/buffer/previous-non-emacs-buffer tmp-orig))))
#+END_SRC

** Eshell
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun rcoedo/eshell/maybe-bol ()
        (interactive)
        (let ((p (point)))
          (eshell-bol)
          (if (= p (point))
              (beginning-of-line))))

  (defun rcoedo/eshell/eshell-here ()
    "Opens up a new shell in the directory associated with the
  current buffer's file. The eshell is renamed to match that
  directory to make multiple eshell windows easier."
    (interactive)
    (let* ((parent (if (buffer-file-name)
                       (file-name-directory (buffer-file-name))
                     default-directory))
           (height (/ (window-total-height) 3))
           (name   (car (last (split-string parent "/" t)))))
      (split-window-vertically (- height))
      (other-window 1)
      (eshell "new")
      (rename-buffer (concat "*eshell: " name "*"))

      (insert (concat "ls"))
      (eshell-send-input)))

  (defun rcoedo/eshell/clear ()
    "Clear the eshell buffer."
    (let ((inhibit-read-only t))
      (erase-buffer)
      (eshell-send-input)))

  (defun rcoedo/eshell/projectile-eshell-popup ()
    (interactive)
    (let* ((height (/ (window-total-height) 3))
           (name   (projectile-project-root)))
      (split-window-vertically (- height))
      (other-window 1)
      (eshell "new")
      (rename-buffer (concat "*eshell: " name "*"))

      (cd (projectile-project-root)))
    (rcoedo/eshell/clear)
    (insert "ls")
    (eshell-send-input))

  (defun rcoedo/eshell/projectile-eshell ()
    (interactive)
    (eshell "new")
    (rename-buffer (concat "*eshell: " name "*"))
    (cd (projectile-project-root))
    (rcoedo/eshell/clear)
    (insert "ls")
    (eshell-send-input))

  (defun rcoedo/eshell/x ()
    (kill-buffer-and-window))
#+END_SRC
** Window
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun rcoedo/window/call-other (fun position)
    (lambda (args)
      (select-window (if (eq position 'below) (split-window-below) (split-window-right)))
      (funcall fun args)))

  (defun rcoedo/window/split-vertically-focus ()
    "Splits the window vertically and then focus the new window"
    (interactive)
    (split-window-vertically)
    (other-window 1))

  (defun rcoedo/window/split-horizontally-focus ()
    "Splits the window horizontally and then focus the new window"
    (interactive)
    (split-window-horizontally)
    (other-window 1))

  (defun rcoedo/window/split-vertically-focus-next-buffer ()
    "Splits the window vertically, focus the new window and loads next non emacs buffer"
    (interactive)
    (rcoedo/window/split-vertically-focus)
    (rcoedo/buffer/next-non-emacs-buffer))

  (defun rcoedo/window/split-horizontally-focus-next-buffer ()
    "Splits the window horizontally, focus the new window and loads next non emacs buffer"
    (interactive)
    (rcoedo/window/split-horizontally-focus)
    (rcoedo/buffer/next-non-emacs-buffer))

  (defun rcoedo/window/split-vertically-next-buffer ()
    "Splits the window vertically and then focus the new window"
    (interactive)
    (rcoedo/window/split-vertically-focus-next-buffer)
    (other-window -1))

  (defun rcoedo/window/split-horizontally-next-buffer ()
    "Splits the window horizontally and then focus the new window"
    (interactive)
    (rcoedo/window/split-horizontally-focus-next-buffer)
    (other-window -1))

  (defun rcoedo/window/split-bottom-panel ()
    "Splits the window vertically to open a bottom panel"
    (interactive)
    (split-window-vertically (floor (* 0.80 (window-height)))))
#+END_SRC

** Java
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun rcoedo/java/java-eval-nofocus ()
    "run current program (that requires no input)"
    (interactive)
    (let* ((source (file-name-nondirectory buffer-file-name))
           (out    (file-name-sans-extension source))
           (class  (concat out ".class")))
      (save-buffer)
      (shell-command (format "rm -f %s" class))
      (shell-command (format "javac %s" source))
      (if (file-exists-p class)
          (shell-command (format "java %s" out) "*scratch*")
          (shell-command (format "javac %s" source) "*scratch*"))))
#+END_SRC

* Package settings
** Evil
*** Evil mode
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package evil
    :config
    (evil-mode t)

    (defvar evil-mode-list
      '((eshell-mode           insert)
        (comint-mode           insert)
        (alchemist-iex-mode    insert)
        (magit-mode            emacs)
        (magit-status          emacs)
        (magit-log-mode        emacs)
        (magit-commit-mode     emacs)
        (magit-diff-mode       emacs)
        (magit-popup-mode      emacs)
        (magit-merge-popup     emacs)
        (magit-revision-mode   emacs)
        (direx:direx-mode      emacs)
        (git-commit-mode       insert)
        (cider-stacktrace-mode insert)))

    (dolist (mode evil-mode-list)
      (evil-set-initial-state (nth 0 mode) (nth 1 mode)))

    (define-key evil-normal-state-map "\C-p" nil)
    (define-key evil-normal-state-map (kbd "<tab>") 'other-window)

    (define-key evil-insert-state-map "\C-a" 'beginning-of-line)
    (define-key evil-insert-state-map "\C-e" 'end-of-line)
    (define-key evil-insert-state-map "\C-f" 'forward-char)
    (define-key evil-insert-state-map "\C-b" 'backward-char)
    (define-key evil-insert-state-map "\C-d" 'delete-char)
    (define-key evil-insert-state-map "\C-n" 'next-line)
    (define-key evil-insert-state-map "\C-p" 'previous-line)
    (define-key evil-insert-state-map "\C-w" 'evil-delete)
    (define-key evil-insert-state-map "\C-k" 'kill-line)

    (define-key evil-motion-state-map (kbd "<right>") nil)
    (define-key evil-motion-state-map (kbd "<left>")  nil)
    (define-key evil-motion-state-map (kbd "<down>")  nil)
    (define-key evil-motion-state-map (kbd "<up>")    nil))
#+END_SRC

*** Evil leader
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package evil-leader
    :require evil
    :config
    (global-evil-leader-mode)
    (setq evil-leader/in-all-states t)

    (evil-leader/set-leader "<SPC>")
    (evil-leader/set-key
      "yy"    'helm-show-kill-ring
      "cc"    'evilnc-comment-or-uncomment-lines
      "cp"    'evilnc-copy-and-comment-lines
      "cb"    'evilnc-comment-or-uncomment-paragraphs
      "co"    'evilnc-comment-operator
      "sh"    'evil-search-highlight-persist-remove-all)

    (setq rcoedo/evil-leader/mode-leader "<SPC>")

    (defun rcoedo/evil-leader/prefix-mode-binding (element)
      (cons (concat rcoedo/evil-leader/mode-leader (car element)) (cdr element)))

    (defun rcoedo/evil-leader/set-mode-keys (mode bindings)
      (let ((prefixed-bindings (-map 'rcoedo/evil-leader/prefix-mode-binding bindings))
            (set-key '(lambda (binding) (evil-leader/set-key-for-mode mode (car binding) (car (cdr binding))))))
        (-map set-key prefixed-bindings))))
#+END_SRC

*** Evil surround
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package evil-surround
    :require evil
    :config
    (global-evil-surround-mode t)
    (define-key evil-visual-state-map "s" 'evil-surround-region)
    (define-key evil-normal-state-map "s" 'evil-surround-edit))
#+END_SRC

*** Evil search highlight persist
#+BEGIN_SRC emacs-lisp :tangle yes
(req-package evil-search-highlight-persist
  :require evil
  :config
  (global-evil-search-highlight-persist t)
  (custom-set-faces '(evil-search-highlight-persist-highlight-face ((t (:foreground "white" :background "#718c00"))))))
#+END_SRC

*** Evil matchit
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package evil-matchit
    :require evil
    :config
    (progn
      (global-evil-matchit-mode t)))
#+END_SRC

*** Evil lisp state
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package evil-lisp-state
    :init
    (progn
      (setq evil-lisp-state-global t
            evil-lisp-state-enter-lisp-state-on-command nil))
    :config
    (progn
      (add-to-list 'evil-lisp-state-major-modes 'clojure-mode)
      (define-key evil-lisp-state-map (kbd "o") 'lisp-state-insert-sexp-after)
      (define-key evil-lisp-state-map (kbd "O") 'lisp-state-insert-sexp-before)
      (evil-lisp-state-leader "L")))
#+END_SRC

*** Evil org
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package evil-org
    :init
    (progn
      (add-hook 'org-mode-hook 'evil-org-mode)))
#+END_SRC

** Projectile
*** Projectile
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package projectile
    :require ghq
    :config
    (progn (setq projectile-enable-caching t
                 projectile-switch-project-action 'projectile-dired
                 projectile-ignored-project-function #'(lambda (project-root) 'true)
                 projectile-completion-system 'helm
                 projectile-globally-ignored-directories (append '(".cask") projectile-globally-ignored-files)
                 projectile-project-root-files ())
           (projectile-global-mode)))
#+END_SRC

*** Rails
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package projectile-rails
    :require projectile
    :init
    (progn
      (add-hook 'projectile-mode-hook 'projectile-rails-on)))
#+END_SRC

** Helm
*** Helm config
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package helm-config)
#+END_SRC

*** Helm
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package helm
    :require helm-config
    :config
    ;; (setq helm-ff-skip-boring-files t
    ;;       helm-boring-file-regexp-list   '("\\.git$" "\\.hg$" "\\.svn$" "\\.CVS$" "\\._darcs$" "\\.la$" "\\.o$" "~$" "\\.so$" "\\.a$"
    ;;                                        "\\.elc$" "\\.fas$" "\\.fasl$" "\\.pyc$" "\\.pyo$" "bower_components" "node_modules")
    ;;       helm-boring-buffer-regexp-list '("\\` " "\\*helm" "\\*helm-mode" "\\*Echo Area" "\\*tramp" "\\*Minibuf" "\\*epc"))

    ;; (advice-add 'helm-ff-filter-candidate-one-by-one
    ;;             :around (lambda (fcn file)
    ;;                       (unless (string-match "\\(?:/\\|\\`\\)\\.\\{1,2\\}\\'" file)
    ;;                         (funcall fcn file))))

    (setq helm-exit-idle-delay 0)
    (helm-autoresize-mode t)
    (helm-mode t)

    (define-key global-map (kbd "C-x C-f")    'helm-find-files)
    (define-key global-map (kbd "M-x")        'helm-M-x)
    (define-key global-map (kbd "C-SPC")      'helm-mini)
    (define-key helm-map   (kbd "<tab>")      'helm-execute-persistent-action)
    (define-key helm-map   (kbd "C-i")        'helm-execute-persistent-action)
    (define-key helm-map   (kbd "C-z")        'helm-select-action)
    (define-key helm-map   (kbd "C-k")        'helm-previous-source)
    (define-key helm-map   (kbd "C-j")        'helm-next-source)

    (define-key helm-buffer-map     (kbd "<C-backspace>")
      #'(lambda () (interactive) (with-helm-alive-p (helm-exit-and-execute-action (lambda (buffer) (kill-buffer buffer) (helm-mini))))))

    (define-key helm-buffer-map     (kbd "<C-return>")
      #'(lambda () (interactive) (with-helm-alive-p (helm-exit-and-execute-action (rcoedo/window/call-other 'switch-to-buffer 'right)))))

    (define-key helm-buffer-map     (kbd "<C-S-return>")
      #'(lambda () (interactive) (with-helm-alive-p (helm-exit-and-execute-action (rcoedo/window/call-other 'switch-to-buffer 'below)))))

    (define-key helm-find-files-map (kbd "<C-return>")
      #'(lambda () (interactive) (with-helm-alive-p (helm-exit-and-execute-action (rcoedo/window/call-other 'find-file 'right)))))

    (define-key helm-find-files-map (kbd "<C-S-return>")
      #'(lambda () (interactive) (with-helm-alive-p (helm-exit-and-execute-action (rcoedo/window/call-other 'find-file 'below))))))
#+END_SRC

*** Helm projectile
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package helm-projectile
    :require projectile helm grep
    :config
    (helm-projectile-toggle 1)
    (setq projectile-switch-project-action 'projectile-dired) ;; Override helm-projectile-on setting
    (define-key projectile-command-map (kbd "s s") 'helm-projectile-ag)
    (define-key projectile-command-map (kbd "p") 'helm-ghq-list)
    (define-key helm-projectile-find-file-map (kbd "<C-return>")
      #'(lambda () (interactive) (with-helm-alive-p (helm-exit-and-execute-action (rcoedo/window/call-other 'find-file 'right)))))
    (define-key helm-projectile-find-file-map (kbd "<C-S-return>")
      #'(lambda () (interactive) (with-helm-alive-p (helm-exit-and-execute-action (rcoedo/window/call-other 'find-file 'below))))))
#+END_SRC

*** Helm dash
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package helm-dash
    :require helm
    :config
    (progn
      (defun rcoedo/helm-dash/setup-docsets (hook docsets)
        (add-hook hook `(lambda ()
                          (setq-local helm-dash-common-docsets ',docsets)
                          (setq helm-current-buffer (current-buffer)))))

      (define-key global-map (kbd "M-d") 'helm-dash-at-point)
      (define-key global-map (kbd "M-D") 'helm-dash)
      (setq helm-dash-browser-func 'eww
            helm-dash-docsets-path "~/.emacs.d/docsets"
            helm-dash-common-docsets (sort
                                      (let (value)
                                        (dolist (element
                                                 (directory-files helm-dash-docsets-path nil "\\.docset$" 1)
                                                 value)
                                          (setq value (cons (file-name-sans-extension element) value))))
                                      'string-lessp))))
#+END_SRC

** Yasnippet
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package yasnippet
    :init
    (progn
      (defun rcoedo/yasnippet/bindings ()
        (define-key yas-minor-mode-map (kbd "<tab>") nil)
        (define-key yas-minor-mode-map (kbd "TAB") nil)
        (define-key yas-minor-mode-map (kbd "<C-return>") 'yas-expand))

      (defun rcoedo/yasnippet/hook ()
        (rcoedo/yasnippet/bindings))

      (add-hook 'yas-minor-mode-hook 'rcoedo/yasnippet/hook))
    :config
    (yas-global-mode t))
#+END_SRC
** Perspective
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package perspective
    :config
    (persp-mode-set-prefix-key (kbd "C-j"))
    (define-key persp-mode-map (kbd "C-j C-n") 'persp-next)
    (define-key persp-mode-map (kbd "C-j C-p") 'persp-prev)
    (define-key persp-mode-map (kbd "C-j C-j") 'other-window)
    (define-key persp-mode-map (kbd "C-j h") 'windmove-left)
    (define-key persp-mode-map (kbd "C-j j") 'windmove-down)
    (define-key persp-mode-map (kbd "C-j k") 'windmove-up)
    (define-key persp-mode-map (kbd "C-j l") 'windmove-right)
    (persp-mode t))
#+END_SRC
** Expand region
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package expand-region
    :require evil
    :config
    (progn
      (define-key evil-normal-state-map "-" 'er/expand-region)))
#+END_SRC
** Eval in repl
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package eval-in-repl
    :defer t)
#+END_SRC

** Ghq
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package ghq)
#+END_SRC
** Markdown
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package markdown-mode
    :mode "\\.md\\'")
#+END_SRC
** Comint
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package comint
    :defer t
    :require evil
    :config
    (add-hook 'comint-mode-hook
              #'(lambda ()
                  (evil-define-key 'insert comint-mode-map
                    (kbd "C-r") 'helm-comint-input-ring
                    (kbd "C-p") 'comint-previous-input
                    (kbd "C-n") 'comint-next-input))))
#+END_SRC

** Company
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package company
    :defer t
    :require helm-company
    :config
    (add-hook 'after-init-hook 'global-company-mode)
    (add-hook 'global-company-mode-hook
              #'(lambda ()
                  (setq company-idle-delay 0
                        company-dabbrev-downcase nil)
                  (define-key company-active-map (kbd "M-n") nil)
                  (define-key company-active-map (kbd "M-p") nil)
                  (define-key company-active-map (kbd "\C-n") 'company-select-next)
                  (define-key company-active-map (kbd "\C-p") 'company-select-previous))))
#+END_SRC
    
** Eshell
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package eshell
    :defer t
    :require evil
    :config
    (setq eshell-history-size 1000
          eshell-aliases-file (concat user-emacs-directory "eshell-aliases")
          eshell-prompt-function #'(lambda nil (concat (getenv "USER") "@" (system-name) ":"
                                                       (abbreviate-file-name (eshell/pwd))
                                                       (if (= (user-uid) 0) " # " " $ "))))

    (add-hook 'eshell-mode-hook #'(lambda ()
                                    (evil-define-key 'insert eshell-mode-map
                                      (kbd "C-a") 'rcoedo/eshell/maybe-bol
                                      (kbd "C-r") 'helm-eshell-history
                                      (kbd "C-p") 'eshell-previous-matching-input-from-input
                                      (kbd "C-n") 'eshell-next-matching-input-from-input)

                                    (company-mode -1)

                                    (defalias 'ff 'find-file)
                                    (defalias 'd  'dired))))
#+END_SRC

** Flycheck
#+BEGIN_SRC emacs-lisp :tangle yes
(req-package flycheck
  :defer t
  :init
  (add-hook 'after-init-hook 'global-flycheck-mode))
#+END_SRC

** Elixir
#+BEGIN_SRC emacs-lisp :tangle yes
(req-package elixir-mode
  :defer t
  :require smartparens
  :config
  (setq blink-matching-delay 0.1)

  (add-hook 'elixir-mode-hook 'alchemist-mode)

  (defun my-elixir-do-end-close-action (id action context)
    (when (eq action 'insert)
      (newline-and-indent)
      (forward-line -1)
      (indent-according-to-mode)))

  (sp-with-modes '(elixir-mode)
    (sp-local-pair "->" "end"
                   :when '(("RET"))
                   :post-handlers '(:add my-elixir-do-end-close-action)
                   :actions '(insert)))

  (sp-with-modes '(elixir-mode)
    (sp-local-pair "do" "end"
                   :when '(("SPC" "RET"))
                   :post-handlers '(:add my-elixir-do-end-close-action)
                   :actions '(insert))))
#+END_SRC

** Smartparens
#+BEGIN_SRC emacs-lisp :tangle yes
(req-package smartparens-config
  :config
  (smartparens-global-mode))
#+END_SRC

** Latex
#+BEGIN_SRC emacs-lisp :tangle yes
(req-package tex-mode
  :defer t
  :init
  (add-to-list 'auto-mode-alist '("\\.tex$\\'" . latex-mode))
  :config
  (add-hook 'latex-mode-hook
            #'(lambda ()
                (flyspell-mode t)
                (ispell-change-dictionary "english")
                (local-unset-key (kbd "C-SPC")))))
#+END_SRC

** Elm
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package elm-mode
    :defer t
    :require flycheck company
    :init
    (add-to-list 'auto-mode-alist '("\\.elm\\'" . elm-mode))
    :config
    (progn
      (setq elm-format-on-save t)
      (add-to-list 'company-backends 'company-elm)
      (add-hook 'elm-mode-hook #'elm-oracle-setup-completion)
      (add-hook 'flycheck-mode-hook 'flycheck-elm-setup)))
#+END_SRC

** Lua
#+BEGIN_SRC emacs-lisp :tangle yes
(req-package lua-mode
  :defer t
  :require flycheck
  :init
  (add-to-list 'auto-mode-alist '("\\.lua$" . lua-mode))
  (add-to-list 'interpreter-mode-alist '("lua" . lua-mode)))
#+END_SRC

** Guide-key
#+BEGIN_SRC emacs-lisp :tangle yes
(req-package guide-key
  :config
  (setq guide-key/guide-key-sequence '("<SPC>" "C-c")
        guide-key/recursive-key-sequence-flag t
        guide-key/idle-delay 0.1
        guide-key/popup-window-position 'bottom)
  (guide-key-mode t))
#+END_SRC

** Javascript
*** Js2
#+BEGIN_SRC emacs-lisp :tangle yes
;;  (req-package js2-mode :require flycheck
;;    :mode "\\.js\\'"
;;    :config
;;    (progn
;;      (defun rcoedo/js2-mode/bindings ()
;;        (define-key js2-mode-map (kbd "M-v") 'babel-repl-send-paragraph)
;;        (rcoedo/evil-leader/set-mode-keys
;;         'js2-mode
;;         '(("oe" js2-mode-toggle-element)
;;           ("ow" js2-mode-toggle-warnings-and-errors)
;;           ("oc" js2-mode-toggle-hide-comments)
;;           ("of" js2-mode-toggle-hide-functions)
;;           ("oa" js2-mode-show-all))))
;;
;;      (defun rcoedo/js2-mode/hook ()
;;        (rcoedo/js2-mode/bindings))
;;
;;      (setq-default js2-basic-offset 2)
;;      (add-hook 'js2-mode-hook 'rcoedo/js2-mode/hook)))
#+END_SRC

*** Rjsx
#+BEGIN_SRC emacs-lisp :tangle yes
;;  (req-package rjsx-mode :require flycheck
;;    :mode "\\.jsx?\\'"
;;    :require flycheck
;;    :config
;;    (progn
;;      (defun rcoedo/rjsx-mode/bindings ()
;;        (define-key rjsx-mode-map (kbd "M-v") 'babel-repl-send-paragraph)
;;        (define-key rjsx-mode-map (kbd "<") nil)
;;        (rcoedo/evil-leader/set-mode-keys
;;         'rjsx-mode
;;         '(("<" nil))))
;;
;;      (defun rcoedo/rjsx-mode/hook ()
;;        (rcoedo/rjsx-mode/bindings))
;;
;;      (add-hook 'rjsx-mode-hook 'rcoedo/rjsx-mode/hook)))
#+END_SRC

*** Babel repl
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package babel-repl
    :require comint
    :config
    (progn
      (add-to-list 'comint-preoutput-filter-functions
                   (lambda (output)
                     (replace-regexp-in-string "'use strict'" ""
                                               (replace-regexp-in-string
                                                "\033\\[[0-9]+[A-Z]" "" output))))))
#+END_SRC

** Clojure
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package cider-repl
    :defer t
    :init
    (progn
      (defun rcoedo/cider-repl/helm-cider-history ()
        "Show `cider-input-history` in `helm`."
        (interactive)
        (helm :sources (helm-build-sync-source "Helm Cider History"
                         :candidates cider-repl-input-history
                         :action '(("Yank" . (lambda (candidate) (insert candidate))))
                         :persistent-action (lambda (candidate) (ignore))
                         :persistent-help "DoNothing"
                         :multiline t)
              :buffer "*helm cider history*"
              :resume 'noresume))

      (defun rcoedo/cider-repl/bindings ()
        (define-key cider-repl-mode-map (kbd "M-p") nil)
        (define-key cider-repl-mode-map (kbd "M-n") nil)
        (define-key cider-repl-mode-map (kbd "M-r") nil)

        (evil-define-key 'insert cider-repl-mode-map
          (kbd "C-r") 'rcoedo/cider-repl/helm-cider-history
          (kbd "C-p") 'cider-repl-previous-input
          (kbd "C-n") 'cider-repl-next-input))

      (defun rcoedo/cider-repl/hook ()
        (setq cider-cljs-lein-repl
                 "(do (use 'figwheel-sidecar.repl-api) (start-figwheel!) (cljs-repl))")
        (rcoedo/cider-repl/bindings))

      (add-hook 'cider-repl-mode-hook 'rcoedo/cider-repl/hook)))

  (req-package cider
    :defer t
    :init
    (progn
      (defun rcoedo/cider/bindings ()
        (define-key cider-mode-map (kbd "M-v") 'cider-eval-defun-at-point))

      (defun rcoedo/cider/hook ()
        (eldoc-mode t)
        (rcoedo/cider/bindings))

      (add-hook 'cider-mode-hook 'rcoedo/cider/hook)

      (defun rcoedo/cider/figwheel-repl ()
        (interactive)
        (save-some-buffers)
        (with-current-buffer (cider-current-repl-buffer)
          (goto-char (point-max))
          (insert "(require 'figwheel-sidecar.repl-api)
             (figwheel-sidecar.repl-api/start-figwheel!) ; idempotent
             (figwheel-sidecar.repl-api/cljs-repl)")
          (cider-repl-return)))))

  (req-package clojure-mode
    :require helm-dash
    :mode "\\.clj\\'"
    :config
    (progn
      (rcoedo/helm-dash/setup-docsets 'clojure-mode-hook '("Clojure"))
      (defun rcoedo/clojure-mode/hook ()
        (rainbow-delimiters-mode t))

      (add-hook 'clojure-mode-hook 'rcoedo/clojure-mode/hook)))
#+END_SRC

** Ruby
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package enh-ruby-mode
    :mode "\\.rs\\'"
    :init
    (progn
      (add-to-list 'interpreter-mode-alist '("ruby" . enh-ruby-mode))))

  (req-package robe
    :require company
    :init
    (progn
      (add-hook 'ruby-mode-hook 'robe-mode)
      (push 'company-robe company-backends)

      (defun rcoedo/robe/hook ()
        (if (eq nil (get-buffer "*rails*")) (robe-start "yes")))

      (add-hook 'robe-mode-hook 'rcoedo/robe/hook)))
#+END_SRC

** Python
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package anaconda-mode
    :require company eval-in-repl-python
    :init
    (progn
      (defun rcoedo/anaconda-mode/bindings ()
        (define-key python-mode-map (kbd "M-v") 'eir-eval-in-python))

      (defun rcoedo/anaconda-mode/hook ()
        (pyenv-mode t)
        (anaconda-mode t)
        (eldoc-mode t)
        (rcoedo/anaconda-mode/bindings))

      (add-to-list 'company-backends 'company-anaconda)
      (add-hook 'python-mode-hook 'rcoedo/anaconda-mode/hook)))
#+END_SRC

** Haskell
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package
    :mode "\\.hs\\'"
    :commands haskell-mode
    :init
    (progn
      (defun rcoedo/haskell/bindings ()
        (eval-after-load 'haskell-mode '(progn
                                          (define-key haskell-mode-map (kbd "C-c C-l") 'haskell-process-load-or-reload)
                                          (define-key haskell-mode-map (kbd "C-c C-z") 'haskell-interactive-switch)
                                          (define-key haskell-mode-map (kbd "C-c C-n C-t") 'haskell-process-do-type)
                                          (define-key haskell-mode-map (kbd "C-c C-n C-i") 'haskell-process-do-info)
                                          (define-key haskell-mode-map (kbd "C-c C-n C-c") 'haskell-process-cabal-build)
                                          (define-key haskell-mode-map (kbd "C-c C-n c") 'haskell-process-cabal)))
        (eval-after-load 'haskell-cabal '(progn
                                           (define-key haskell-cabal-mode-map (kbd "C-c C-z") 'haskell-interactive-switch)
                                           (define-key haskell-cabal-mode-map (kbd "C-c C-k") 'haskell-interactive-mode-clear)
                                           (define-key haskell-cabal-mode-map (kbd "C-c C-c") 'haskell-process-cabal-build)
                                           (define-key haskell-cabal-mode-map (kbd "C-c c") 'haskell-process-cabal))))

      (defun rcoedo/haskell/hook ()
        (interactive-haskell-mode 1)
        (hindent-mode 1)
        (custom-set-variables
         '(haskell-process-suggest-remove-import-lines t)
         '(haskell-process-auto-import-loaded-modules t)
         '(haskell-process-log t)
         '(haskell-process-type 'cabal-repl))
        (rcoedo/haskell/bindings))

      (add-hook 'haskell-mode-hook 'rcoedo/haskell/hook)))
#+END_SRC

** Web
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package web-mode
    :defer t
    :require flycheck
    :init
    (add-to-list 'auto-mode-alist '("\\.phtml\\'"     . web-mode))
    (add-to-list 'auto-mode-alist '("\\.tpl\\.php\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.[agj]sp\\'"   . web-mode))
    (add-to-list 'auto-mode-alist '("\\.as[cp]x\\'"   . web-mode))
    (add-to-list 'auto-mode-alist '("\\.erb\\'"       . web-mode))
    (add-to-list 'auto-mode-alist '("\\.mustache\\'"  . web-mode))
    (add-to-list 'auto-mode-alist '("\\.djhtml\\'"    . web-mode))
    (add-to-list 'auto-mode-alist '("\\.ejs\\'"       . web-mode))
    (add-to-list 'auto-mode-alist '("\\.jsx?\\'"      . web-mode))
    :config
    (progn 
      (setq-default flycheck-disabled-checkers
                     (append flycheck-disabled-checkers '(javascript-jshint)))

      (setq web-mode-content-types-alist
            '(("jsx" . "\\.js[x]?\\'")))

      (add-to-list 'web-mode-comment-formats '("jsx" . "//" ))
      (add-to-list 'web-mode-comment-formats '("javascript" . "//" ))

      (flycheck-add-mode 'javascript-eslint 'web-mode)))

      (add-hook 'web-mode-hook
                #'(lambda ()
                    (setq web-mode-auto-quote-style nil)
                    (setq web-mode-attr-indent-offset 2)
                    (setq web-mode-markup-indent-offset 2)
                    (setq web-mode-css-indent-offset 2)
                    (setq web-mode-code-indent-offset 2)))
#+END_SRC
** CSS
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package css-mode
    :mode "\\.css\\'"
    :init
    (progn
      (defun rcoedo/css-mode/bindings ()
        (rcoedo/evil-leader/set-mode-keys 'css-mode
                                          '(("f" helm-css-scss))))

      (defun rcoedo/css-mode/hook ()
        (rcoedo/css-mode/bindings)
        (setq css-indent-offset 2))

      (add-hook 'css-mode-hook 'rcoedo/css-mode/hook)))
#+END_SRC

** SCSS
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package scss-mode
    :mode "\\.scss\\'"
    :init
    (progn
      (defun rcoedo/scss-mode/bindings ()
        (rcoedo/evil-leader/set-mode-keys 'scss-mode
                                          '(("f" helm-css-scss))))

      (defun rcoedo/scss-mode/hook ()
        (rcoedo/scss-mode/bindings)
        (setq css-indent-offset 2))

      (setq scss-compile-at-save nil)
      (add-hook 'scss-mode-hook 'rcoedo/scss-mode/hook)))
#+END_SRC

** Rainbow mode
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package rainbow
    :defer t
    :init
    (progn
      (setq rainbow-html-colors-major-mode-list '(css-mode
                                                  html-mode
                                                  scss-mode
                                                  web-mode))
      (dolist (mode rainbow-html-colors-major-mode-list)
        (add-hook (intern (format "%s-hook" mode)) 'rainbow-mode))))
#+END_SRC

** Cc mode
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package cc-mode
    :defer t
    :init
    (progn
      (defun rcoedo/java-mode/bindings ()
        (define-key java-mode-map (kbd "M-v") 'rcoedo/java/java-eval-nofocus))

      (add-hook 'java-mode-hook 'rcoedo/java-mode/bindings)))
#+END_SRC

** Emmet
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package emmet-mode
    :defer t
    :require web-mode
    :init
    (progn
      (defun rcoedo/emmet-mode/bindings ()
        (define-key emmet-mode-keymap (kbd "C-j") nil))

      (add-hook 'less-css-mode 'emmet-mode)
      (add-hook 'scss-mode-hook 'emmet-mode)
      (add-hook 'web-mode-hook 'emmet-mode))
      (add-hook 'emmet-mode-hook 'rcoedo/emmet-mode/bindings))
#+END_SRC
** Magit
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package magit
    :bind (("C-c g s"   . magit-status)
           ("C-c g l l" . magit-log)
           ("C-c g l c" . magit-log-current)))
#+END_SRC

** Popwin
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package popwin
    :config
    (popwin-mode 1))
#+END_SRC

** Direx
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package direx
    :require popwin projectile
    :config
    (push '(direx:direx-mode :position left :width 40 :dedicated t :stick t)
          popwin:special-display-config)
    (add-hook 'direx:direx-mode-hook #'(lambda ()
                                         (setq mode-line-format nil)
                                         (linum-mode -1)))
    (global-set-key (kbd "C-x t") #'(lambda ()
                                      (interactive)
                                      (direx:find-directory-other-window (projectile-project-root)))))
#+END_SRC

** Org mode
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package org
    :config
    (progn
      (defun rcoedo/org-mode/bindings ()
        (rcoedo/evil-leader/set-mode-keys 'org-mode
         '(("t" org-babel-tangle)))

        (define-key org-mode-map (kbd "<S-right>") nil)
        (define-key org-mode-map (kbd "<S-left>")  nil)
        (define-key org-mode-map (kbd "C-'")       nil))

      (add-hook 'org-mode-hook 'rcoedo/org-mode/bindings)))
#+END_SRC
   
** Transpose frame
#+BEGIN_SRC emacs-lisp :tangle yes
    (req-package transpose-frame
      :config
      (define-key global-map (kbd "M-f") 'flip-frame)
      (define-key global-map (kbd "M-F") 'flop-frame)
      (define-key global-map (kbd "M-r") 'rotate-frame-clockwise)
      (define-key global-map (kbd "M-R") 'rotate-frame-anticlockwise))
#+END_SRC

** Elisp mode
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package lisp-mode
    :init
    (progn
      (defun rcoedo/lisp-mode/bindings ()
        (define-key emacs-lisp-mode-map (kbd "M-v") 'eval-defun))

      (defun rcoedo/lisp-mode/hook ()
        (rcoedo/lisp-mode/bindings)
        (rainbow-delimiters-mode t))

      (add-hook 'emacs-lisp-mode-hook 'rcoedo/lisp-mode/hook)))
#+END_SRC

** Octave
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package octave
    :mode ("\\.m$" . octave-mode)
    :init
    (progn
      (defun rcoedo/octave-mode/bindings ()
        (define-key octave-mode-map (kbd "M-v") 'octave-send-defun))

      (defun rcoedo/octave-mode/hook ()
        (rcoedo/octave-mode/bindings))

      (add-hook 'octave-mode-hook 'rcoedo/octave-mode/hook)))
#+END_SRC

** ESS
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package ess-site
    :disabled t
    :mode ("\\.R$" . R-mode)
    :init
    (progn
      (defun rcoedo/ess-mode/bindings ()
        (define-key ess-mode-map (kbd "M-v") 'ess-eval-paragraph-and-step))

      (defun rcoedo/ess-mode/hook ()
        (rcoedo/ess-mode/bindings))

      (add-hook 'ess-mode-hook 'rcoedo/ess-mode/hook)))
#+END_SRC

** Eww
#+BEGIN_SRC emacs-lisp :tangle yes
  (req-package eww
    :defer t
    :config
    (progn
      (evil-define-key 'normal eww-mode-map
        (kbd "q") 'quit-window)))
#+END_SRC

* TODO Globals
#+BEGIN_SRC emacs-lisp :tangle yes
  (put 'dired-find-alternate-file 'disabled nil)
  (put 'erase-buffer 'disabled nil)                 ; Allow the use of erase-buffer
  (windmove-default-keybindings)                    ; Move between windows with shift + arrow keys
  (transient-mark-mode t)                           ; Show the mark as selected
  (global-auto-revert-mode t)                       ; Reload buffers when they change outside emacs

  (setq-default c-basic-offset 4
                truncate-lines nil
                prefer-coding-system 'utf-8
                indent-tabs-mode nil
                global-auto-revert-non-file-buffers t ;; Auto-revert
                auto-revert-verbose nil
                tab-width 4
                backup-inhibited t
                auto-save-default nil
                rcoedo/layout/layout-list '(rcoedo/layout/three rcoedo/layout/four rcoedo/layout/side-by-side rcoedo/layout/bottom-panel))

  (eval-after-load 'undo-tree '(progn (define-key undo-tree-map (kbd "C-/") nil)))

  (define-key key-translation-map (kbd "C-,") (kbd "C-x")) ;; These bring sanity to my fingers
  (define-key key-translation-map (kbd "C-.") (kbd "C-c"))
  (define-key key-translation-map "\e"        (kbd "C-g"))

  (define-key global-map (kbd "M-]")           'rcoedo/buffer/next-non-emacs-buffer)
  (define-key global-map (kbd "M-[")           'rcoedo/buffer/previous-non-emacs-buffer)
  (define-key global-map (kbd "M-q")           'rcoedo/eshell/projectile-eshell-popup)
  (define-key global-map (kbd "M-s")           'helm-projectile-ag)
  (define-key global-map (kbd "M-t")           'helm-projectile-find-file)
  (define-key global-map (kbd "M-p")           'helm-ghq-list)
  (define-key global-map (kbd "C-x C-r")       'rcoedo/buffer/rename-current-file)
  (define-key global-map (kbd "C-x C-d")       'rcoedo/buffer/delete-current-file)
  (define-key global-map (kbd "C-x C-k")       'kill-this-buffer)
  (define-key global-map (kbd "C-x k")         'kill-buffer-and-window)
  (define-key global-map (kbd "M-/")           'evilnc-comment-or-uncomment-lines)

  (define-key global-map (kbd "H-1") 'windmove-left)
  (define-key global-map (kbd "H-2") 'windmove-down)
  (define-key global-map (kbd "H-3") 'windmove-up)
  (define-key global-map (kbd "H-4") 'windmove-right)

  (define-key global-map (kbd "\C-x2") (lambda () (interactive)(split-window-vertically) (other-window 1)))
  (define-key global-map (kbd "\C-x3") (lambda () (interactive)(split-window-horizontally) (other-window 1)))
#+END_SRC

* It's about time
#+BEGIN_SRC emacs-lisp :tangle yes
(req-package-finish)
#+END_SRC
